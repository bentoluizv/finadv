# AI Coding Standards: FinAdv

## Role & Tone
Act as a Lead Python Developer. Prioritize simplicity, type safety, and functional programming.

## How You Will Work
- **Before larger changes:** Read `AGENT.md` for project layout, protocols, and workflows. Use the existing base resource (`_base/`) and patterns instead of inventing new ones.
- **Product & UX:** When adding screens, forms, or flows, follow the “Product & UX: How the app works” section in AGENT.md (user stories, functional and non-functional requirements). Implement only what supports those; do not add features outside the described MVP.
- **Layers and order:** Implement or change in this order when adding features: models → repository (and factory) → logic → routes → templates → tests. Do not put DB or business logic in routes; do not put session usage outside repository.
- **Reuse first:** For new resources, use the base model (id, timestamps), base repository helpers (generic CRUD), and base layout. Add partials or a resource factory only when a real use case exists.
- **Small, focused edits:** Prefer a few clear edits per step. One logical change per commit when the user commits (see AGENT.md for commit rules).
- **After editing code:** Run `uv run task check` (ruff + ty) when you change Python under `src`; fix any new issues before considering the task done.
- **When debugging or refactoring:** Follow the flow route → logic → repository; change the layer that owns the responsibility (e.g. validation in route, rules in logic, persistence in repository).
- **Tests:** Add or update tests in the resource’s `tests/` when adding or changing behavior; use shared fixtures from `ext` or root `conftest.py`. Add a resource factory only when tests need controlled ids or construction from dict.

## Structural Constraints
- **Location:** All code must live in `/src`.
- **Base Resource:** `src/resources/_base/` holds reusable pieces: base models (id, created_at, updated_at), base repository helpers (generic CRUD), and one layout template. Add partials only when a feature needs them. Do not mount routes for `_base`.
- **Resource Pattern:** Group by domain. A new resource (e.g., `debts`) must contain `models.py`, `logic.py`, `repository.py`, `routes.py`, `templates/`, and `tests/`. Use base model and base repository; add a resource factory only when overrides or construction-from-dict are needed.
- **External Pattern:** Infrastructure (DB, API clients) must live in `/src/ext`.

## Technical Requirements (Python 3.14)
- **Async-first:** All I/O must be async: use `async def` for routes, repository functions, logic that calls the repository or external APIs, and any other I/O. Use `AsyncSession` (SQLModel) for DB; use async HTTP clients for API calls. Do not use sync `Session` or blocking calls in request-handling paths.
- **Dependency Management:** Always use `uv`.
- **Typing:** Use `ty`. Every function must have complete type hints.
- **Data Modeling:** Use `SQLModel`. Inherit from `SQLModel, table=True` only for DB entities.
- **Repository:** All DB access (CRUD, queries) lives in `repository.py` per resource as **async** functions taking `AsyncSession`. Logic and routes call repository functions; they do not use the session directly.
- **Factory:** Add a factory per resource only when needed (explicit id/timestamps in tests, building from dict, or repeated construction logic). If the model’s default_factory is enough, instantiate the model directly; do not add a factory “for consistency.”
- **Functional Logic:** Business rules in `logic.py` are async when they call the repository or external APIs; routes `await` them. Routes only validate, await logic/repository, and return; no business or DB logic in routes.
- **FastAPI:** Use `APIRouter(prefix=..., tags=...)`, `Depends()` for async session and deps, `response_model` and explicit status codes. Route handlers are `async def` and keep thin.

## UI Pattern (HTMX, FastHX, htmy)
- **Fragments first:** Prefer returning small HTML fragments for `hx-swap` (rows, tables, form regions) over full pages. Use full pages only for top-level shells (layout + initial content).
- **FastHX decorators:** Use a single `HTMY` instance from `fasthx.htmy.HTMY` and decorate routes with `@htmy.page(...)` for full pages and `@htmy.hx(...)` for HTMX endpoints. Routes return data; components (htmy/Jinja) render the HTML.
- **htmy components:** Prefer htmy **function components** (`@component`, `@component.context_only`) and, when needed, class-based components with an `htmy(context)` method, following the htmy components/function-components guides. Use simple factories that return components when you do not need access to context.
- **Styling:** Use Tailwind CSS via **pytailwindcss**; favor utility classes in templates and htmy components instead of large custom CSS files.
- **UX:** Clear labels, semantic HTML, and keyboard-friendly interactions. Prefer small, focused screens; avoid features or flows not in the MVP (see AGENT.md Product & UX). Avoid introducing a SPA framework or heavy custom JavaScript unless the user explicitly requests it.

## Style
- **Ruff format and lint:** Use **single quotes** for strings, **2-space** indentation, **88**-character line length. Lint rule sets (in `pyproject.toml`): E (pycodestyle), F (Pyflakes), I (isort), UP (pyupgrade), B (bugbear), C4 (comprehensions), SIM (simplify). Fix violations rather than disabling rules; use `# noqa` only for genuine false positives with a brief comment. See AGENT.md **Ruff (lint and format)** for full explanations and recommendations.
- **Variables over inline calls:** Prefer assigning the result of a function (or method) to a variable, then using or returning that variable, instead of returning or using the function call directly (e.g. `settings = get_settings(); url = settings.database_url` rather than `get_settings().database_url` inline). Improves readability and debugging.

## Avoid redundancy and unnecessary code
- **Single source of truth:** Do not duplicate values (e.g. do not re-export settings as another name elsewhere).
- **One entry point per concept:** Prefer one way to obtain something unless the framework requires another (e.g. Depends(get_settings)).
- **YAGNI:** Do not add placeholder files, stub partials, or “for later” helpers. Add code when a feature needs it.
- **Lean tests:** Test behavior; merge tests that assert the same concern; avoid testing the framework.
- **Minimal exports:** Export only what other modules use.

## Code Smells to Avoid
- **Deep Nesting:** If code is more than 3 levels deep, refactor.
- **Class Overuse:** Avoid classes unless required by SQLModel/Pydantic (Repository and Factory are modules/functions, not fat service classes).
- **The "Manager" Trap:** Do not create `DebtManager` or `IncomeService` classes. Use repository + logic modules instead.

## Simplicity over Complexity
